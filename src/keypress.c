/* keypress.c */

/*
 * Copyright (C) 2025, Leo Abramovich <leo.clifm@outlook.com>
 * All rights reserved.

* The MIT License (MIT)

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

#define _XOPEN_SOURCE 700

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h> /* getopt() */
#include <string.h>
#include <stdint.h> /* uint8_t */
#include <termios.h>
#include <locale.h>
#include <ctype.h>
#include <errno.h>  /* ENOMEM */
#include <limits.h> /* CHAR_MIN, CHAR_MAX */
#include <wchar.h>  /* wcswidth() */

#include "translate_key.h" /* translate_key(), is_end_seq_char() */

#define PROG_NAME "keypress"
#define VERSION   "0.3.2"

/* Some escape sequences */
#define CLEAR_SCREEN     fputs("\x1b[H\x1b[2J\x1b[3J", stdout)
#define HIDE_CURSOR      fputs("\x1b[?25l", stdout)
#define UNHIDE_CURSOR    fputs("\x1b[?25h", stdout)
#define SET_KITTY_KEYS   fputs("\x1b[>1u", stdout);
#define UNSET_KITTY_KEYS fputs("\x1b[<u", stdout);
#define SET_ALT_SCREEN   fputs("\x1b[?1049h", stdout);
#define UNSET_ALT_SCREEN fputs("\x1b[?1049l", stdout);

/* Ctrl+C */
#define KITTY_EXIT_KEY(s, c) (*(s) == ESC_KEY && \
	(c) == 'u' && strcmp((s) + 1, "[99;5") == 0)
/* Ctrl+X */
#define KITTY_CLR_KEY(s, c) (*(s) == ESC_KEY && \
	(c) == 'u' && strcmp((s) + 1, "[120;5") == 0)

#define EXIT_KEY  0x03 /* Ctrl+C */
#define CLR_KEY   0x18 /* Ctrl+X */
#define ESC_KEY   0x1b /* Esc */
#define DEL_KEY   0x7f /* Del */
#define NBSP_KEY  0xa0 /* NBSP */
#define SHY_KEY   0xad /* SHY */
#define SPACE_KEY 0x20 /* Space */

#define TABLE_WIDTH 35
#define IS_CTRL_KEY(c)    ((c) >= 0 && (c) <= 31)
#define IS_OCTAL_DIGIT(c) ((c) >= '0' && (c) <= '7')

#define IS_UTF8_LEAD_BYTE(c) (((c) & 0xc0) == 0xc0)
#define IS_UTF8_CONT_BYTE(c) (((c) & 0xc0) == 0x80)
#define IS_UTF8_CHAR(c)      (IS_UTF8_LEAD_BYTE((c)) || IS_UTF8_CONT_BYTE((c)))

/* 32 bytes to hold bytes of an escape sequence or a UTF-8 character */
#define BUF_SIZE 32

int g_kitty_keys = 0;

/* Symbols for control characters */
const char *const keysym[] = {
	"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
	"BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI", "DLE",
	"DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN",
	"EM", "SUB", "ESC", "FS", "GS", "RS", "US", "SP", NULL
};

static int
utf8_char_bytes(unsigned char c)
{
    c >>= 4;
    c &= 7;

	return (c == 4) ? 2 : c - 3;
}

static size_t
wc_xstrlen(const char *restrict str)
{
	wchar_t wbuf[PATH_MAX];
	const size_t len = mbstowcs(wbuf, str, (size_t)PATH_MAX);
	if (len == (size_t)-1) /* Invalid multi-byte sequence found */
		return 0;

	const int width = wcswidth(wbuf, len);
	if (width != -1)
		return (size_t)width;

	return 0; /* A non-printable wide char was found */
}

static void
print_help(void)
{
	puts("Usage: keypress [OPTIONS]\n");
	puts("  -c      Clear the screen before printing key information in\n"
		"          interactive mode.");
	puts("  -h      Display this help and exit.");
	puts("  -k      Enable support for the Kitty keyboard protocol.");
	puts("  -n      Disable colors.");
	puts("  -t SEQ  Run in translation mode: translate the escape sequence\n"
		"          SEQ into its corresponding text/symbolic representation\n"
		"          and exit.");
	puts("  -v      Display version information and exit.");

	printf("\nBy default, %s runs in interactive mode: it generates a\n"
		"byte-by-byte representation of keyboard inputs, whether for\n"
		"individual keys or key combinations.\n\n"
		"The output includes the following formats: hexadecimal, octal,\n"
		"decimal, and the corresponding symbols.\n", PROG_NAME);

	puts("\nMulti-byte Sequences:\n"
		 "Sequences such as extended ASCII, Unicode, or key combinations\n"
		 "involving function keys and arrow keys, will produce multiple\n"
		 "lines of output, with each line representing a single byte in\n"
		 "the sequence.");

	puts("\nImportant Notes:\n"
		 " - The generated byte values may vary depending on the terminal\n"
		 "   emulator used.\n"
		 " - Pasting from the primary clipboard is allowed.\n"
		 " - To quit the program, press 'Ctrl+c'.\n"
		 " - To clear the screen, press 'Ctrl+x'.\n"
		 " - These key combinations are reserved for controlling the\n"
		 "   program's flow, so they will not be represented in the output.\n");

	puts("Reserved Key Combinations:\n"
		 "  The byte values for these keys are:\n\n"
		 "   ┌──────┬──────┬─────┬──────────┬──────┐\n"
		 "   │ Hex  │ Oct  │ Dec │   Bin    │ Sym  │\n"
		 "   ├──────┼──────┼─────┼──────────┼──────┤\n"
		 "   │ \\x18 │ \\030 │  24 │ 00011000 │  CAN │ (Ctrl+x)\n"
		 "   │ \\x03 │ \\003 │   3 │ 00000011 │  ETX │ (Ctrl+c)\n"
		 "   └──────┴──────┴─────┴──────────┴──────┘");
}

#define HEADER_COLOR "\x1b[32m" /* Header */
#define CODE_COLOR   "\x1b[2m"  /* Code (hex, oct, dec) */
#define SYM_COLOR    "\x1b[2;36m" /* Symbol */
#define TRANS_COLOR  "\x1b[1m"  /* Translation */
#define RESET        "\x1b[0m"

struct color_t {
	char *header;
	char *code;
	char *symbol;
	char *translation;
	char *reset;
};
static struct color_t color = {0};

struct opts_t {
	char *translate;
	int clear_screen;
	int color;
	int kitty_keys;
};

#define DEFAULT_CLEAR_SCREEN 0
#define DEFAULT_COLOR 1
#define DEFAULT_TRANSLATE NULL
#define DEFAULT_KITTY_KEYS 0

static void
init_default_options(struct opts_t *options)
{
	options->clear_screen = DEFAULT_CLEAR_SCREEN;
	options->color        = DEFAULT_COLOR;
	options->translate    = DEFAULT_TRANSLATE;
	options->kitty_keys   = DEFAULT_KITTY_KEYS;
}

static void
set_colors(const int enabled)
{
	color.code = enabled == 1 ? CODE_COLOR : "";
	color.header = enabled == 1 ? HEADER_COLOR : "";
	color.symbol = enabled == 1 ? SYM_COLOR : "";
	color.translation = enabled == 1 ? TRANS_COLOR : "";
	color.reset = enabled == 1 ? RESET : "";
}

static void
parse_args(const int argc, char **argv, struct opts_t *options)
{
	int opt;
	while ((opt = getopt(argc, argv, "chknt:v")) != -1) {
		switch (opt) {
		case 'c': options->clear_screen = 1; break;
		case 'k': options->kitty_keys = g_kitty_keys = 1; break;
		case 'n': options->color = 0; break;
		case 't': options->translate = optarg; break;
		case 'v': printf("%s\n", VERSION); exit(EXIT_SUCCESS);
		case 'h': /* fallthrough */
		default: print_help(); exit(EXIT_SUCCESS);
		}
	}

	set_colors(options->color);
}

/* Transform escape strings ("\\e", hex, and octal) in the string INPUT
 * into the corresponding integer byte. The converted string is copied
 * into the OUTPUT buffer. */
static void
transform_esc_seq(const char *input, char *output)
{
	const char *ptr = input;
	char *out_ptr = output;

	while (*ptr) {
		if (*ptr != '\\') {
			/* Not an escape string: copy the character as is. */
			*out_ptr++ = *ptr++;
		} else if (ptr[1] == 'e') { /* "\\e" */
			*out_ptr++ = ESC_KEY;
			ptr += 2;
		} else if (ptr[1] == 'x'     /* Hex */
		|| IS_OCTAL_DIGIT(ptr[1])) { /* Octal */
			const int hex = ptr[1] == 'x';
			const long n = strtol(ptr + (hex ? 2 : 1), NULL, hex ? 16 : 8);
			if (n < CHAR_MIN || n > CHAR_MAX) {
				ptr++;
			} else {
				*out_ptr++ = (char)n;
				ptr += 4;
			}
		} else {
			*out_ptr++ = *ptr++;
		}
	}

	*out_ptr = '\0';
}

static int
run_translate_key(const char *arg)
{
	if (!arg) {
		fprintf(stderr, "Missing parameter: An escape sequence is expected\n");
		fprintf(stderr, "E.g.: %s -t \"\\x1b[1;11D\"\n", PROG_NAME);
		return EXIT_FAILURE;
	}

#ifdef TK_TEST
	if (strcmp(arg, "test") == 0)
		return key_test();
#endif

	char *str = malloc((strlen(arg) + 1) * sizeof(char));
	if (!str)
		return ENOMEM;

	transform_esc_seq(arg, str);

	char *key_sym = translate_key(str);
	free(str);

	if (key_sym) {
		printf("%s\n", key_sym);
		free(key_sym);
		return EXIT_SUCCESS;
	}

	fprintf(stderr, "%s: '%s': Unknown escape sequence\n", PROG_NAME, arg);
	return EXIT_FAILURE;
}

struct termios orig_termios;

static void
switch_to_alternate_buffer(void)
{
	SET_ALT_SCREEN;
	HIDE_CURSOR;
	if (g_kitty_keys == 1) SET_KITTY_KEYS;
}

static void
switch_to_normal_buffer(void)
{
	if (g_kitty_keys == 1) UNSET_KITTY_KEYS;
	UNHIDE_CURSOR;
	UNSET_ALT_SCREEN;
}

static void
disable_raw_mode(void)
{
	tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
}

static void
enable_raw_mode(void)
{
	tcgetattr(STDIN_FILENO, &orig_termios);
	struct termios raw = orig_termios;
	raw.c_lflag &= (tcflag_t)~(ICANON | ECHO | ISIG);
	raw.c_iflag &= (tcflag_t)~(IXON | IXOFF | ICRNL | INPCK);
	tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}

static void
deinit_term(void)
{
	switch_to_normal_buffer();
    disable_raw_mode();
}

static void
init_term(void)
{
	setlocale(LC_ALL, "");
	switch_to_alternate_buffer();
	enable_raw_mode();
}

static void
print_header(void)
{
	CLEAR_SCREEN;
	printf(" %s %s  (C-c: quit, C-x: clear)\n"
		" ┌──────┬──────┬─────┬──────────┬──────┐\n"
		" │ %sHex%s  │ %sOct%s  │ %sDec%s │   %sBin%s    │ %sSym%s  │\n"
		" ├──────┼──────┼─────┼──────────┼──────┤\n", PROG_NAME, VERSION,
		color.header, color.reset, color.header, color.reset,
		color.header, color.reset, color.header, color.reset,
		color.header, color.reset);
}

static void
print_footer(char *buf, const int is_utf8, const int clear_screen)
{
	static int edge = TABLE_WIDTH + 5;

	char *str = translate_key(buf);
	const int wlen = (str && is_utf8 == 1) ? (int)wc_xstrlen(str) : 0;
	if (wlen == 0 && str && strlen(str) > TABLE_WIDTH - 1)
		str[TABLE_WIDTH] = '\0';

	printf(" ├──────┴──────┴─────┴──────────┴──────┤\n"
		" │ %s%s%s\x1b[%dG│\n", color.translation, str ? str : "?",
		color.reset, edge);

	if (clear_screen == 0)
		printf(" ├─────────────────────────────────────┤\n");
	else
		printf(" └─────────────────────────────────────┘\n");

	memset(buf, '\0', BUF_SIZE);
	free(str);
}

/* Return a pointer to a string holding the binary representation of the byte N. */
static char *
build_binary(const uint8_t n)
{
	static char bin[9] = {0};

	for (int i = 0; i < 8; i++)
		bin[7 - i] = (n & (1u << i)) ? '1' : '0';
	bin[8] = '\0';

	return bin;
}

static void
print_row(const int c, const char *s)
{
	printf(" │ %s\\x%02x%s │ %s\\%03o%s │ %s%3d%s │ %s%s%s │ %s%*s%s │\n",
		color.code, c, color.reset,
		color.code, c, color.reset,
		color.code, c, color.reset,
		color.code, build_binary((uint8_t)c), color.reset,
		color.symbol, 4, s, color.reset);
}

static void
print_bottom_line(const int clear_screen)
{
	if (clear_screen == 0)
		printf(" ├──────┼──────┼─────┼──────────┼──────┤\n");
	else
		printf(" └──────┴──────┴─────┴──────────┴──────┘\n");
}

static char *
get_ctrl_keysym(const int c)
{
	switch (c) {
	case DEL_KEY:   return "DEL";
	case NBSP_KEY:  return "NBSP";
	case SHY_KEY:   return "SHY";
	case SPACE_KEY: return "SP";
	default:        return "";
	}
}

int
main(int argc, char **argv)
{
	struct opts_t options = {0};
	init_default_options(&options);
	parse_args(argc, argv, &options);

	if (options.translate != NULL) /* -t SEQ */
		return run_translate_key(options.translate);

	init_term();

	char buf[BUF_SIZE] = "";
	char *ptr = buf;
	int clr_scr = 0;

	int utf8_bytes = 0; /* Number of bytes of a UTF-8 character. */
	int utf8_count = 0; /* Number of printed bytes of a UTF-8 character. */

	print_header();

	unsigned char ch = 0;
	while (read(STDIN_FILENO, &ch, sizeof(ch)) == sizeof(ch)) {
		const int c = (int)ch;

		if (c == EXIT_KEY || KITTY_EXIT_KEY(buf, c)) /* Ctrl+C */
			break;

		if (KITTY_CLR_KEY(buf, c)) { /* Ctrl+X (kitty protocol) */
			clr_scr = 0; print_header();
			memset(buf, 0, sizeof(buf)); ptr = buf;
			continue;
		} else if (c == CLR_KEY /* Ctrl+X */
		|| clr_scr == 1) {
			clr_scr = 0; print_header();
			if (c == CLR_KEY)
				continue; /* Ctrl+X: do not print info about this key.  */
		}

		if (IS_CTRL_KEY(c)) { /* Control characters */
			print_row(c, keysym[c]);
		} else if (isprint(c) && c != 0x20) { /* ASCII printable characters */
			char s[2] = {(char)c, 0};
			print_row(c, s);
		} else { /* Extended ASCII, Unicode */
			print_row(c, get_ctrl_keysym(c));

			if (IS_UTF8_CHAR(c)) {
				utf8_count++;
				*ptr++ = (char)c;
				int bytes = IS_UTF8_LEAD_BYTE(c)
					? utf8_char_bytes((unsigned char)c) : 0;
				if (bytes > 1)
					utf8_bytes = bytes;
			}
		}

		if (c == ESC_KEY) {
			*ptr++ = (char)c;
		} else if (c > 0 && (IS_CTRL_KEY(c) || (buf[0] == ESC_KEY
		&& (is_end_seq_char((unsigned char)c)
		|| (!buf[1] && c != '[' && c != 'O'))))) {
			/* Key combination involving modifier keys (Ctrl, Alt, Meta). */
			*ptr++ = (char)c;
			*ptr = '\0';
			print_footer(buf, 0, options.clear_screen);
			ptr = buf;
			clr_scr = options.clear_screen == 1;
		} else if (utf8_bytes > 1 && utf8_count == utf8_bytes) {
			/* A UTF-8 character. */
			utf8_count = utf8_bytes = 0;
			*ptr = '\0';
			print_footer(buf, 1, options.clear_screen);
			ptr = buf;
			clr_scr = options.clear_screen == 1;
		} else if (buf[0] == ESC_KEY) {
			/* Append byte to the buffer only provided we are in the
			 * middle of an escape sequence. */
			*ptr++ = (char)c;
		} else if (!IS_UTF8_CHAR(c)) {
			/* Print a bottom line (ASCII characters only). */
			clr_scr = options.clear_screen == 1;
			print_bottom_line(clr_scr);
		}
	}

	deinit_term();
	return EXIT_SUCCESS;
}
