/* keypress.c */

/*
 * Copyright (C) 2025, Leo Abramovich <leo.clifm@outlook.com>
 * All rights reserved.

* The MIT License (MIT)

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

#define _XOPEN_SOURCE 700

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h> /* getopt() */
#include <string.h>
#include <signal.h>
#include <termios.h>
#include <locale.h>
#include <ctype.h>
#include <errno.h>  /* ENOMEM */
#include <limits.h> /* CHAR_MIN, CHAR_MAX */
#include <wchar.h>  /* wcswidth() */

#include "translate_key.h" /* translate_key(), is_end_seq_char() */

#define PROG_NAME "keypress"
#define VERSION   "0.3.1"

/* Some escape sequences */
#define CLEAR_SCREEN     fputs("\x1b[H\x1b[2J\x1b[3J", stdout)
#define HIDE_CURSOR      fputs("\x1b[?25l", stdout)
#define UNHIDE_CURSOR    fputs("\x1b[?25h", stdout)
#define SET_KITTY_KEYS   fputs("\x1b[>1u", stdout);
#define UNSET_KITTY_KEYS fputs("\x1b[<u", stdout);
#define SET_ALT_SCREEN   fputs("\x1b[?1049h", stdout);
#define UNSET_ALT_SCREEN fputs("\x1b[?1049l", stdout);

#define EXIT_KEY 0x03 /* Ctrl+C */
#define CLR_KEY  0x18 /* Ctrl+X */
#define ESC_KEY  0x1b /* Esc */
#define DEL_KEY  0x7f /* Del */
#define NBSP_KEY 0xa0 /* NBSP */
#define SHY_KEY  0xad /* SHY */

#define TABLE_WIDTH 24
#define IS_CTRL_KEY(c)    ((c) >= 0 && (c) <= 31)
#define IS_OCTAL_DIGIT(c) ((c) >= '0' && (c) <= '7')

#define IS_UTF8_LEAD_BYTE(c) (((c) & 0xc0) == 0xc0)
#define IS_UTF8_CONT_BYTE(c) (((c) & 0xc0) == 0x80)
#define IS_UTF8_CHAR(c)      (IS_UTF8_LEAD_BYTE((c)) || IS_UTF8_CONT_BYTE((c)))

/* 32 bytes to hold bytes of an escape sequence or a UTF-8 character */
#define BUF_SIZE 32

int g_kitty_keys = 0;

/* Symbols for control characters */
const char *const keysym[] = {
	"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
	"BS", "HT", "LF", "CT", "FF", "CR", "SO", "SI", "DLE",
	"DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN",
	"EM", "SUB", "ESC", "FS", "GS", "RS", "US", "SP", NULL
};

static int
utf8_char_bytes(unsigned char c)
{
    c >>= 4;
    c &= 7;

	return (c == 4) ? 2 : c - 3;
}

static size_t
wc_xstrlen(const char *restrict str)
{
	wchar_t wbuf[PATH_MAX];
	const size_t len = mbstowcs(wbuf, str, (size_t)PATH_MAX);
	if (len == (size_t)-1) /* Invalid multi-byte sequence found */
		return 0;

	const int width = wcswidth(wbuf, len);
	if (width != -1)
		return (size_t)width;

	return 0; /* A non-printable wide char was found */
}

static void
print_help(void)
{
	puts("Usage: keypress [OPTIONS]\n");
	puts("  -c      Clear the screen before printing key information in\n"
		"          interactive mode.");
	puts("  -h      Display this help and exit.");
	puts("  -k      Enable support for the Kitty keyboard protocol.");
	puts("  -t SEQ  Run in translation mode: translate the escape sequence\n"
		"          SEQ into its corresponding text/symbolic representation\n"
		"          and exit.");
	puts("  -v      Display version information and exit.");

	printf("\nBy default, %s runs in interactive mode: it generates a\n"
		"byte-by-byte representation of keyboard inputs, whether for\n"
		"individual keys or key combinations.\n\n"
		"The output includes the following formats: hexadecimal, octal,\n"
		"decimal, and the corresponding symbols.\n", PROG_NAME);

	puts("\nMulti-byte Sequences:\n"
		 "Sequences such as extended ASCII, Unicode, or key combinations\n"
		 "involving function keys and arrow keys, will produce multiple\n"
		 "lines of output, with each line representing a single byte in\n"
		 "the sequence.");

	puts("\nImportant Notes:\n"
		 " - The generated byte values may vary depending on the terminal\n"
		 "   emulator used.\n"
		 " - Pasting from the primary clipboard is allowed.\n"
		 " - To quit the program, press 'Ctrl+c'.\n"
		 " - To clear the screen, press 'Ctrl+x'.\n"
		 " - These key combinations are reserved for controlling the\n"
		 "   program's flow, so they will not be represented in the output.\n");

	puts("Reserved Key Combinations:\n"
		 "  The byte values for these keys are:\n\n"
		 "   ┌──────┬──────┬─────┬──────┐\n"
		 "   │ Hex  │ Oct  │ Dec │ Sym  │\n"
		 "   ├──────┼──────┼─────┼──────┤\n"
		 "   │ \\x18 │ \\030 │  24 │  CAN │ (Ctrl+x)\n"
		 "   │ \\x03 │ \\003 │   3 │  ETX │ (Ctrl+c)\n"
		 "   └──────┴──────┴─────┴──────┘");
}

struct opts_t {
	char *translate;
	int clear_screen;
	int kitty_keys;
};

#define DEFAULT_CLEAR_SCREEN 0
#define DEFAULT_TRANSLATE NULL
#define DEFAULT_KITTY_KEYS 0

static void
init_default_options(struct opts_t *options)
{
	options->clear_screen = DEFAULT_CLEAR_SCREEN;
	options->translate    = DEFAULT_TRANSLATE;
	options->kitty_keys   = DEFAULT_KITTY_KEYS;
}

static void
parse_args(const int argc, char **argv, struct opts_t *options)
{
	int opt;
	while ((opt = getopt(argc, argv, "chkt:v")) != -1) {
		switch (opt) {
		case 'c': options->clear_screen = 1; break;
		case 'k': options->kitty_keys = g_kitty_keys = 1; break;
		case 't': options->translate = optarg; break;
		case 'v': printf("%s\n", VERSION); exit(EXIT_SUCCESS);
		case 'h': /* fallthrough */
		default: print_help(); exit(EXIT_SUCCESS);
		}
	}
}

/* Transform escape strings ("\\e", hex, and octal) in the string INPUT
 * into the corresponding integer byte. The converted string is copied
 * into the OUTPUT buffer. */
static void
transform_esc_seq(const char *input, char *output)
{
	const char *ptr = input;
	char *out_ptr = output;

	while (*ptr) {
		if (*ptr != '\\') {
			/* Not an escape string: copy the character as is. */
			*out_ptr++ = *ptr++;
		} else if (ptr[1] == 'e') { /* "\\e" */
			*out_ptr++ = ESC_KEY;
			ptr += 2;
		} else if (ptr[1] == 'x'     /* Hex */
		|| IS_OCTAL_DIGIT(ptr[1])) { /* Octal */
			const int hex = ptr[1] == 'x';
			const long n = strtol(ptr + (hex ? 2 : 1), NULL, hex ? 16 : 8);
			if (n < CHAR_MIN || n > CHAR_MAX) {
				ptr++;
			} else {
				*out_ptr++ = (char)n;
				ptr += 4;
			}
		} else {
			*out_ptr++ = *ptr++;
		}
	}

	*out_ptr = '\0';
}

static int
run_translate_key(const char *arg)
{
	if (!arg) {
		fprintf(stderr, "Missing parameter: An escape sequence is expected\n");
		fprintf(stderr, "E.g.: %s -t \"\\x1b[1;11D\"\n", PROG_NAME);
		return EXIT_FAILURE;
	}

#ifdef TK_TEST
	if (strcmp(arg, "test") == 0)
		return key_test();
#endif

	char *str = malloc((strlen(arg) + 1) * sizeof(char));
	if (!str)
		return ENOMEM;

	transform_esc_seq(arg, str);

	char *key_sym = translate_key(str);
	free(str);

	if (key_sym) {
		printf("%s\n", key_sym);
		free(key_sym);
		return EXIT_SUCCESS;
	}

	fprintf(stderr, "%s: '%s': Unknown escape sequence\n", PROG_NAME, arg);
	return EXIT_FAILURE;
}

struct termios orig_termios;

static void
switch_to_alternate_buffer(void)
{
	SET_ALT_SCREEN;
	HIDE_CURSOR;
	if (g_kitty_keys == 1) SET_KITTY_KEYS;
}

static void
switch_to_normal_buffer(void)
{
	if (g_kitty_keys == 1) UNSET_KITTY_KEYS;
	UNHIDE_CURSOR;
	UNSET_ALT_SCREEN;
}

static void
disable_raw_mode(void)
{
	tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
}

static void
enable_raw_mode(void)
{
	tcgetattr(STDIN_FILENO, &orig_termios);
	struct termios raw = orig_termios;
	raw.c_lflag &= ~(ICANON | ECHO | ISIG);
	raw.c_iflag &= ~(IXON | IXOFF | ICRNL | INPCK);
	tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}

static void
deinit_term(void)
{
	switch_to_normal_buffer();
    disable_raw_mode();
}

static void
handle_sigint(int signal)
{
	(void)signal;
	deinit_term();
    exit(0);
}

static void
set_signals(void)
{
    struct sigaction sa;
    sa.sa_handler = handle_sigint;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    sigaction(SIGINT, &sa, NULL);
}

static void
init_term(void)
{
	setlocale(LC_ALL, "");
	set_signals();
	switch_to_alternate_buffer();
	enable_raw_mode();
}

static void
print_header(void)
{
	CLEAR_SCREEN;
	printf(" %s %s  (C-c: quit, C-x: clear)\n"
		" ┌──────┬──────┬─────┬──────┐\n"
		" │ Hex  │ Oct  │ Dec │ Sym  │\n"
		" ├──────┼──────┼─────┼──────┤\n", PROG_NAME, VERSION);
}

static void
print_footer(char *buf, const int is_utf8, const int clear_screen)
{
	char *str = translate_key(buf);
	const int wlen = (str && is_utf8 == 1) ? (int)wc_xstrlen(str) : 0;

	printf(" ├──────┴──────┴─────┴──────┤\n");
	printf(" │ %-*s │\n", TABLE_WIDTH + wlen, str ? str : "?");
	if (clear_screen == 0)
		printf(" ├──────────────────────────┤\n");
	else
		printf(" └──────────────────────────┘\n");

	memset(buf, '\0', BUF_SIZE);
	free(str);
}

static void
print_row(const int c, const char *s)
{
	printf(" │ \\x%02x │ \\%03o │ %3d │ %*s │\n", c, c, c, 4, s);
}

static void
print_bottom_line(const int clear_screen)
{
	if (clear_screen == 0)
		printf(" ├──────┼──────┼─────┼──────┤\n");
	else
		printf(" └──────┴──────┴─────┴──────┘\n");
}

int
main(int argc, char **argv)
{
	struct opts_t options = {0};
	init_default_options(&options);
	parse_args(argc, argv, &options);

	if (options.translate != NULL) /* -t SEQ */
		return run_translate_key(options.translate);

	init_term();

	char buf[BUF_SIZE] = "";
	char *ptr = buf;
	int clr_scr = 0;

	int utf8_bytes = 0; /* Number of bytes of a UTF-8 character. */
	int utf8_count = 0; /* Number of printed bytes of a UTF-8 character. */

	print_header();

	unsigned char ch = 0;
	while (read(STDIN_FILENO, &ch, sizeof(ch)) == sizeof(ch)) {
		const int c = (int)ch;

		if (c == EXIT_KEY) /* Ctrl+C */
			break;

		/* Ctrl+X (kitty protocol) */
		if (*buf == ESC_KEY && strcmp(buf + 1, "[120;5") == 0 && c == 'u') {
			clr_scr = 0; print_header();
			continue;
		} else if (c == CLR_KEY /* Ctrl+X */
		|| clr_scr == 1) {
			clr_scr = 0; print_header();
			if (c == CLR_KEY)
				continue; /* Ctrl+X: do not print info about this key.  */
		}

		if (IS_CTRL_KEY(c)) { /* Control characters */
			print_row(c, keysym[c]);
		} else if (isprint(c)) { /* ASCII printable characters */
			char s[2] = {(char)c, 0};
			print_row(c, s);
		} else { /* Extended ASCII, Unicode */
			const char *s = (c == DEL_KEY ? "DEL"
				: (c == NBSP_KEY ? "NBSP" : (c == SHY_KEY ? "SHY" : "")));
			print_row(c, s);

			if (IS_UTF8_CHAR(c)) {
				utf8_count++;
				*ptr++ = c;
				int bytes = IS_UTF8_LEAD_BYTE(c)
					? utf8_char_bytes((unsigned char)c) : 0;
				if (bytes > 1)
					utf8_bytes = bytes;
			}
		}

		if (c == ESC_KEY) {
			*ptr++ = c;
		} else if (IS_CTRL_KEY(c) || (buf[0] == ESC_KEY && (is_end_seq_char(c)
		|| (!buf[1] && c != '[' && c != 'O')))) {
			/* Key combination involving modifier keys (Ctrl, Alt, Meta). */
			*ptr++ = c;
			*ptr = '\0';
			print_footer(buf, 0, options.clear_screen);
			ptr = buf;
			clr_scr = options.clear_screen == 1;
		} else if (utf8_bytes > 1 && utf8_count == utf8_bytes) {
			/* A UTF-8 character. */
			utf8_count = utf8_bytes = 0;
			*ptr = '\0';
			print_footer(buf, 1, options.clear_screen);
			ptr = buf;
			clr_scr = options.clear_screen == 1;
		} else if (buf[0] == ESC_KEY) {
			/* Append byte to the buffer only provided we are in the
			 * middle of an escape sequence. */
			*ptr++ = c;
		} else if (!IS_UTF8_CHAR(c)) {
			/* Print a bottom line (ASCII characters only). */
			clr_scr = options.clear_screen == 1;
			print_bottom_line(clr_scr);
		}
	}

	deinit_term();
	return EXIT_SUCCESS;
}
