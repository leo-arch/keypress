/* keypress.c */

/*
 * Copyright (C) 2025, Leo Abramovich <leo.clifm@outlook.com>
 * All rights reserved.

* The MIT License (MIT)

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

#define _XOPEN_SOURCE 700

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h> /* getopt() */
#include <string.h>
#include <curses.h>
#include <locale.h>
#include <ctype.h>
#include <errno.h> /* ENOMEM */
#include <limits.h> /* CHAR_MIN, CHAR_MAX */
#include <wchar.h> /* wcswidth() */

#include "translate_key.h"

#define PROG_NAME "keypress"
#define VERSION "0.2.2"

#define KP_HEADER \
" Keypress %s  (C-c: quit, C-x: clear)\n"  \
" ┌──────┬──────┬─────┬──────┐\n"          \
" │ Hex  │ Oct  │ Dec │ Sym  │\n"          \
" ├──────┼──────┼─────┼──────┤\n"

#define BOTTOM_NO_CLR " ├──────────────────────────┤\n"
#define BOTTOM_CLR    " └──────────────────────────┘\n"
#define BOTTOM_NO_CLR_SINGLE " ├──────┼──────┼─────┼──────┤\n"
#define BOTTOM_CLR_SINGLE    " └──────┴──────┴─────┴──────┘\n"

#define END_CHAR(c) (((c) >= 'A' && (c) <= 'D') || ((c) >= 'a' && (c) <= 'd') \
	|| ((c) >= 'P' && (c) <= 'S') || (c) == 'F' || (c) == 'H' || (c) == '~'   \
	|| (c) == '@' || (c) == '^' || (c) == '$')
#define EXIT_KEY 3
#define CLR_KEY  24
#define TABLE_WIDTH 24
#define IS_CTRL_KEY(c) ((c) >= 0 && (c) <= 31)
#define ESC_KEY 27

#define IS_UTF8_LEAD_BYTE(c) (((c) & 0xc0) == 0xc0)
#define IS_UTF8_CONT_BYTE(c) (((c) & 0xc0) == 0x80)
#define IS_UTF8_CHAR(c)      (IS_UTF8_LEAD_BYTE((c)) || IS_UTF8_CONT_BYTE((c)))

static int
utf8_char_bytes(unsigned char c)
{
    c >>= 4;
    c &= 7;

    if (c == 4)
		return 2;

	return c - 3;
}

static size_t
wc_xstrlen(const char *restrict str)
{
	wchar_t wbuf[PATH_MAX];
	const size_t len = mbstowcs(wbuf, str, (size_t)PATH_MAX);
	if (len == (size_t)-1) /* Invalid multi-byte sequence found */
		return 0;

	const int width = wcswidth(wbuf, len);
	if (width != -1)
		return (size_t)width;

	return 0; /* A non-printable wide char was found */
}

static void
print_help(void)
{
	puts("Usage: keypress [OPTIONS]\n");
	puts("  -c      Clear the screen before printing key information in\n"
		"          interactive mode.");
	puts("  -h      Display this help and exit.");
	puts("  -t SEQ  Run in translation mode: translate the escape sequence\n"
		"          SEQ into its corresponding text/symbolic representation\n"
		"          and exit.");
	puts("  -v      Display version information and exit.");

	printf("\nBy default, %s runs in interactive mode: it generates a\n"
		"byte-by-byte representation of keyboard inputs, whether for\n"
		"individual keys or key combinations.\n\n"
		"The output includes the following formats: hexadecimal, octal,\n"
		"decimal, and the corresponding symbols.\n", PROG_NAME);

	puts("\nMulti-byte Sequences:\n"
		 "Sequences such as extended ASCII, Unicode, or key combinations\n"
		 "involving function keys and arrow keys, will produce multiple\n"
		 "lines of output, with each line representing a single byte in\n"
		 "the sequence.");

	puts("\nImportant Notes:\n"
		 " - The generated byte values may vary depending on the terminal\n"
		 "   emulator used.\n"
		 " - Pasting from the primary clipboard is allowed.\n"
		 " - To quit the program, press 'Ctrl+c'.\n"
		 " - To clear the screen, press 'Ctrl+x'.\n"
		 " - These key combinations are reserved for controlling the\n"
		 "   program's flow, so they will not be represented in the output.\n");

	puts("Reserved Key Combinations:\n"
		 "  The byte values for these keys are:\n\n"
		 "   ┌──────┬──────┬─────┬──────┐\n"
		 "   │ Hex  │ Oct  │ Dec │ Sym  │\n"
		 "   ├──────┼──────┼─────┼──────┤\n"
		 "   │ \\x18 │ \\030 │  24 │  CAN │ (Ctrl+x)\n"
		 "   │ \\x03 │ \\003 │   3 │  ETX │ (Ctrl+c)\n"
		 "   └──────┴──────┴─────┴──────┘");
}

struct opts_t {
	char *translate;
	int clear_screen;
};

#define DEFAULT_CLEAR_SCREEN 0
#define DEFAULT_TRANSLATE NULL

static void
init_default_options(struct opts_t *options)
{
	options->clear_screen = DEFAULT_CLEAR_SCREEN;
	options->translate    = DEFAULT_TRANSLATE;
}

static void
parse_args(const int argc, char **argv, struct opts_t *options)
{
	int opt;
	while ((opt = getopt(argc, argv, "cht:v")) != -1) {
		switch (opt) {
		case 'c': options->clear_screen = 1; break;
		case 't': options->translate = optarg; break;
		case 'v': printf("%s\n", VERSION); exit(EXIT_SUCCESS);
		case 'h': /* fallthrough */
		default: print_help(); exit(EXIT_SUCCESS);
		}
	}
}

/* Transform escape strings ("\\e", hex, and octal) in the string INPUT
 * into the corresponding integer byte. The converted string is copied
 * into the OUTPUT buffer. */
static void
transform_esc_seq(const char *input, char *output)
{
	const char *ptr = input;
	char *out_ptr = output;

	while (*ptr) {
		if (*ptr != '\\') {
			/* Not an escape string: copy the character as is. */
			*out_ptr++ = *ptr++;
		} else if (ptr[1] == 'e') { /* "\\e" */
			*out_ptr++ = '\x1b';
			ptr += 2;
		} else if (ptr[1] == 'x' /* Hex */
		|| (ptr[1] >= '0' && ptr[1] <= '9')) { /* Octal */
			const int hex = ptr[1] == 'x';
			const long n = strtol(ptr + (hex ? 2 : 1), NULL, hex ? 16 : 8);
			if (n < CHAR_MIN || n > CHAR_MAX) {
				ptr++;
			} else {
				*out_ptr++ = (char)n;
				ptr += 4;
			}
		} else {
			*out_ptr++ = *ptr++;
		}
	}

	*out_ptr = '\0';
}

static int
run_translate_key(const char *arg)
{
	if (!arg) {
		fprintf(stderr, "Missing parameter: An escape sequence is expected\n");
		fprintf(stderr, "E.g.: %s -t \"\\x1b[1;11D\"\n", PROG_NAME);
		return EXIT_FAILURE;
	}

#ifdef TK_TEST
	if (strcmp(arg, "test") == 0)
		return key_test();
#endif

	char *str = malloc((strlen(arg) + 1) * sizeof(char));
	if (!str)
		return ENOMEM;

	transform_esc_seq(arg, str);

	char *keysym = translate_key(str);
	free(str);

	if (keysym) {
		printf("%s\n", keysym);
		free(keysym);
		return EXIT_SUCCESS;
	}

	fprintf(stderr, "%s: '%s': Unknown escape sequence\n", PROG_NAME, arg);
	return EXIT_FAILURE;
}

static void
print_footer(char *buf, const int is_utf8, const int clear_screen)
{
	char *str = translate_key(buf);

	const int wlen = (str && is_utf8 == 1) ? (int)wc_xstrlen(str) : 0;

	printw(" ├──────┴──────┴─────┴──────┤\n");
	printw(" │ %-*s │\n", TABLE_WIDTH + wlen, str ? str : "?");
	printw(clear_screen == 0 ? BOTTOM_NO_CLR : BOTTOM_CLR);

	free(str);
}

int
main(int argc, char **argv)
{
	struct opts_t options = {0};
	init_default_options(&options);
	parse_args(argc, argv, &options);

	if (options.translate != NULL)
		return run_translate_key(options.translate);

	/* Tell the C libraries to use user's locale settings. */
	setlocale(LC_ALL, "");

	/* Initialize curses. */
	WINDOW *w = initscr();
	if (w == NULL) {
		fprintf(stderr, "Error initializing the curses library.\n");
		return EXIT_FAILURE;
	}

	raw();            /* Terminal in raw mode, no buffering */
	noecho();         /* Disable echoing */
	nonl();           /* Disable newline/return mapping */
	keypad(w, FALSE); /* FALSE: CSI codes, TRUE: curses codes for keys */
	scrollok(w, 1);	  /* Enable screen scroll */
	curs_set(0);      /* Hide cursor */

	printw(KP_HEADER, VERSION);

	const char *const keysym[] = {
		"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
		"BS", "HT", "LF", "CT", "FF", "CR", "SO", "SI", "DLE",
		"DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN",
		"EM", "SUB", "ESC", "FS", "GS", "RS", "US", "SP", NULL
	};


	char buf[32] = ""; /* 32 bytes to hold a complete escape sequence. */
	char *ptr = buf;
	int clr_scr = 0;

	int utf8_bytes = 0; /* Number of bytes of a UTF-8 character. */
	int utf8_count = 0; /* Number of printed bytes of a UTF-8 character. */

	int c = 0;
	while ((c = getch()) != EXIT_KEY) { /* Ctrl+C */
		if (c == CLR_KEY                /* Ctrl+X */
		|| clr_scr == 1) {
			clr_scr = 0; clear(); refresh(); printw(KP_HEADER, VERSION);
			if (c == CLR_KEY)
				continue; /* Ctrl+X: do not print info about this key.  */
		}

		if (IS_CTRL_KEY(c)) { /* Control characters */
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*s │\n", c, c, c, 4,
				keysym[c]);
		} else if (isprint(c)) { /* ASCII printable characters */
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*c │\n", c, c, c, 4, c);
		} else { /* Extended ASCII, Unicode */
			const char *s = (c == 127 ? "DEL"
				: (c == 160 ? "NBSP" : (c == 173 ? "SHY" : "")));
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*s │\n", c, c, c, 4, s);
			if (IS_UTF8_CHAR(c)) {
				utf8_count++;
				*ptr++ = c;
				int bytes = IS_UTF8_LEAD_BYTE(c)
					? utf8_char_bytes((unsigned char)c) : 0;
				if (bytes > 1)
					utf8_bytes = bytes;
			}
		}

		if (c == ESC_KEY) {
			*ptr++ = c;
		} else if (IS_CTRL_KEY(c) || (buf[0] == ESC_KEY && (END_CHAR(c)
		|| (!buf[1] && c != '[' && c != 'O')))) {
			/* Key combination involving modifier keys (Ctrl, Alt, Meta). */
			*ptr++ = c;
			*ptr = '\0';
			print_footer(buf, 0, options.clear_screen);
			memset(buf, '\0', sizeof(buf));
			ptr = buf;
			clr_scr = options.clear_screen == 1;
		} else if (utf8_bytes > 1 && utf8_count == utf8_bytes) {
			/* A UTF-8 character. */
			utf8_count = utf8_bytes = 0;
			*ptr = '\0';
			print_footer(buf, 1, options.clear_screen);
			memset(buf, '\0', sizeof(buf));
			ptr = buf;
			clr_scr = options.clear_screen == 1;
		} else if (buf[0] == ESC_KEY) {
			/* Append byte to the buffer only provided we are in the
			 * middle of an escape sequence. */
			*ptr++ = c;
		} else if (!IS_UTF8_CHAR(c)) {
			/* Print a bottom line (ASCII characters only). */
			clr_scr = options.clear_screen == 1;
			printw(clr_scr == 0 ? BOTTOM_NO_CLR_SINGLE : BOTTOM_CLR_SINGLE);
		}

	}

	curs_set(1); /* Unhide cursor */
	endwin();
	return EXIT_SUCCESS;
}
