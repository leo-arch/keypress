/* keypress.c */

/*
 * Copyright (C) 2025, Leo Abramovich <leo.clifm@outlook.com>
 * All rights reserved.

* The MIT License (MIT)

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <curses.h>
#include <locale.h>
#include <ctype.h>
#include <errno.h> // ENOMEM

#include "translate_key.h"

#define PROG_NAME "keypress"
#define VERSION "0.2"

#define KP_HEADER \
" Keypress %s  (C-c: quit, C-x: clear)\n"  \
" ┌──────┬──────┬─────┬──────┐\n"          \
" │ Hex  │ Oct  │ Dec │ Sym  │\n"          \
" ├──────┼──────┼─────┼──────┤\n"

static void
print_help(void)
{
	puts("Usage: keypress [-h,--help|-v,--version|-t SEQ]\n");
	printf("%s runs in two modes:\n\n", PROG_NAME);
	printf("If running with -t, translate the escape sequence SEQ into the\n"
		"corresponding symbolic representation. For example:\n\n"
		"  %s -t $(printf \"\\x1b[1;11D\")\n\n"
		"will output 'Alt+Meta+Left'.\n\n", PROG_NAME);
	printf("Otherwise, %s generates a byte-by-byte representation of keyboard\n"
		"inputs, whether for individual keys or key combinations. This\n"
		"representation includes the following formats: hexadecimal, octal,\n"
		"decimal, and the corresponding symbols.\n", PROG_NAME);
	puts("\nMulti-byte sequences —such as extended ASCII, Unicode, or key\n"
		"combinations involving function keys and arrow keys— will produce\n"
		"multiple lines of output, with each line representing a single byte in\n"
		"the sequence.");
	puts("\nBe aware that the generated byte values may vary depending on the\n"
		"terminal emulator used.");
	puts("\nPasting from the primary clipboard is allowed.");
	puts("\nWithin the program, press 'Ctrl+c' to quit or 'Ctrl+x' to clear the\n"
		"screen.");
	puts("\nPlease note that these key combinations are reserved for controlling\n"
		"the program's flow, so they will not be represented in the output. For\n"
		"reference, the byte values for these keys are:\n\n"
		" ┌──────┬──────┬─────┬──────┐\n"
		" │ Hex  │ Oct  │ Dec │ Sym  │\n"
		" ├──────┼──────┼─────┼──────┤\n"
		" │ \\x18 │ \\030 │  24 │  CAN │ (Ctrl+x)\n"
		" │ \\x03 │ \\003 │   3 │  ETX │ (Ctrl+c)\n"
		" └──────┴──────┴─────┴──────┘");
}

/* Transform escape string representations ("\\e", "\\x1b", and "\\003")
 * in the string INPUT into the corresponding escape byte. The converted
 * string is copied into the OUTPUT buffer. */
static void
transform_esc_seq(const char *input, char *output)
{
	const char *ptr = input;
	char *out_ptr = output;

	while (*ptr) {
		if (strncmp(ptr, "\\e", 2) == 0) {
			*out_ptr++ = '\x1b';
			ptr += 2;
		} else if (strncmp(ptr, "\\x1b", 4) == 0) {
			*out_ptr++ = '\x1b';
			ptr += 4;
		} else if (strncmp(ptr, "\\003", 4) == 0) {
			*out_ptr++ = '\x1b';
			ptr += 4;
		} else {
			/* Not an escape string: copy the character as is. */
			*out_ptr++ = *ptr++;
		}
	}

	*out_ptr = '\0';
}

static int
run_translate_key(const char *arg)
{
	if (!arg) {
		fprintf(stderr, "Missing parameter: An escape sequence is expected\n");
		fprintf(stderr, "E.g.: %s -t \"\\x1b[1;11D\"\n", PROG_NAME);
		return EXIT_FAILURE;
	}

#ifdef TK_TEST
	if (strcmp(arg, "test") == 0)
		return key_test();
#endif

	char *str = malloc((strlen(arg) + 1) * sizeof(char));
	if (!str)
		return ENOMEM;

	transform_esc_seq(arg, str);

	char *keysym = translate_key(str);
	free(str);

	if (keysym) {
		printf("%s\n", keysym);
		free(keysym);
		return EXIT_SUCCESS;
	}

	printf("No key found!\n");
	return EXIT_FAILURE;
}

static int
run_args(char **argv)
{
	if (!argv || !argv[0] || !argv[1])
		return EXIT_FAILURE;

	if ((argv[1][1] == 'h' && !argv[1][2])
	|| strcmp(argv[1], "--help") == 0) {
		print_help(); return EXIT_SUCCESS;
	}

	if ((argv[1][1] == 'v' && !argv[1][2])
	|| strcmp(argv[1], "--version") == 0) {
		printf("%s\n", VERSION); return EXIT_SUCCESS;
	}

	if ((argv[1][1] == 't' && !argv[1][2])
	|| strcmp(argv[1], "--translate") == 0)
		return run_translate_key(argv[2]);

	return EXIT_FAILURE;
}

int
main(int argc, char **argv)
{
	if (argc >= 2 && *argv[1] == '-')
		return run_args(argv);

	/* Tell the C libraries to use user's locale settings. */
	setlocale(LC_ALL, "");

	/* Initialize curses. */
	WINDOW *w = initscr();
	if (w == NULL) {
		fprintf(stderr, "Error initializing the curses library.\n");
		return EXIT_FAILURE;
	}

	raw();            /* Terminal in raw mode, no buffering */
	noecho();         /* Disable echoing */
	nonl();           /* Disable newline/return mapping */
	keypad(w, FALSE); /* FALSE: CSI codes, TRUE: curses codes for keys */
	scrollok(w, 1);	  /* Enable screen scroll */

	printw(KP_HEADER, VERSION);

	const char *const keysym[] = {
		"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
		"BS", "HT", "LF", "CT", "FF", "CR", "SO", "SI", "DLE",
		"DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN",
		"EM", "SUB", "ESC", "FS", "GS", "RS", "US", "SP", NULL
	};

	int c = 0;
	while ((c = getch()) != 3) { /* Ctrl+c: quit */
		if (c == 24) { /* Ctrl+x: clear the screen */
			clear(); refresh(); printw(KP_HEADER, VERSION);
		} else if (c >= 0 && c <= 32) { /* Control characters */
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*s │\n", c, c, c, 4, keysym[c]);
		} else if (isprint(c)) { /* ASCII printable characters */
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*c │\n", c, c, c, 4, c);
		} else { /* Extended ASCII, Unicode */
			const char *s = (c == 127 ? "DEL"
				: (c == 160 ? "NBSP" : (c == 173 ? "SHY" : "")));
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*s │\n", c, c, c, 4, s);
		}
	}

	endwin();
	return EXIT_SUCCESS;
}
