/* keypress.c */

/*
 * Copyright (C) 2025, Leo Abramovich <leo.clifm@outlook.com>
 * All rights reserved.

* The MIT License (MIT)

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

#define _XOPEN_SOURCE 700

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <curses.h>
#include <locale.h>
#include <ctype.h>
#include <errno.h> /* ENOMEM */
#include <limits.h> /* CHAR_MIN, CHAR_MAX */

#include <wchar.h> /* wcswidth() */

#include "translate_key.h"

#define PROG_NAME "keypress"
#define VERSION "0.2.2"

#define KP_HEADER \
" Keypress %s  (C-c: quit, C-x: clear)\n"  \
" ┌──────┬──────┬─────┬──────┐\n"          \
" │ Hex  │ Oct  │ Dec │ Sym  │\n"          \
" ├──────┼──────┼─────┼──────┤\n"

#define BOTTOM_NO_CLR " ├──────────────────────────┤\n"
#define BOTTOM_CLR    " └──────────────────────────┘\n"
#define BOTTOM_NO_CLR_SINGLE " ├──────┼──────┼─────┼──────┤\n"
#define BOTTOM_CLR_SINGLE    " └──────┴──────┴─────┴──────┘\n"

#define END_CHAR(c) (((c) >= 'A' && (c) <= 'D') || ((c) >= 'a' && (c) <= 'd') \
	|| ((c) >= 'P' && (c) <= 'S') || (c) == 'F' || (c) == 'H' || (c) == '~'   \
	|| (c) == '@' || (c) == '^' || (c) == '$')
#define EXIT_KEY 3
#define CLR_KEY  24
#define TABLE_WIDTH 24
#define IS_CTRL_KEY(c) ((c) >= 0 && (c) <= 31)
#define ESC_KEY 27

#define IS_UTF8_LEAD_BYTE(c) (((c) & 0xc0) == 0xc0)
#define IS_UTF8_CONT_BYTE(c) (((c) & 0xc0) == 0x80)
#define IS_UTF8_CHAR(c)      (IS_UTF8_LEAD_BYTE((c)) || IS_UTF8_CONT_BYTE((c)))

static int
utf8_char_bytes(unsigned char c)
{
    c >>= 4;
    c &= 7;

    if (c == 4)
		return 2;

	return c - 3;
}

static size_t
wc_xstrlen(const char *restrict str)
{
	wchar_t wbuf[PATH_MAX];
	const size_t len = mbstowcs(wbuf, str, (size_t)PATH_MAX);
	if (len == (size_t)-1) /* Invalid multi-byte sequence found */
		return 0;

	const int width = wcswidth(wbuf, len);
	if (width != -1)
		return (size_t)width;

	return 0; /* A non-printable wide char was found */
}

static void
print_help(void)
{
	puts("Usage: keypress [-h,--help|-v,--version|-t SEQ]\n");
	printf("%s runs in two modes:\n\n", PROG_NAME);
	printf("If running with -t, translate the escape sequence SEQ into the\n"
		"corresponding symbolic representation. For example:\n\n"
		"  %s -t \"\\x1b[1;11D\"\n\n"
		"will output 'Alt+Meta+Left'.\n\n", PROG_NAME);
	printf("Otherwise, %s generates a byte-by-byte representation of keyboard\n"
		"inputs, whether for individual keys or key combinations. This\n"
		"representation includes the following formats: hexadecimal, octal,\n"
		"decimal, and the corresponding symbols.\n", PROG_NAME);
	puts("\nMulti-byte sequences —such as extended ASCII, Unicode, or key\n"
		"combinations involving function keys and arrow keys— will produce\n"
		"multiple lines of output, with each line representing a single byte in\n"
		"the sequence.");
	puts("\nBe aware that the generated byte values may vary depending on the\n"
		"terminal emulator used.");
	puts("\nPasting from the primary clipboard is allowed.");
	puts("\nWithin the program, press 'Ctrl+c' to quit or 'Ctrl+x' to clear the\n"
		"screen.");
	puts("\nPlease note that these key combinations are reserved for controlling\n"
		"the program's flow, so they will not be represented in the output. For\n"
		"reference, the byte values for these keys are:\n\n"
		" ┌──────┬──────┬─────┬──────┐\n"
		" │ Hex  │ Oct  │ Dec │ Sym  │\n"
		" ├──────┼──────┼─────┼──────┤\n"
		" │ \\x18 │ \\030 │  24 │  CAN │ (Ctrl+x)\n"
		" │ \\x03 │ \\003 │   3 │  ETX │ (Ctrl+c)\n"
		" └──────┴──────┴─────┴──────┘");
}

/* Transform escape strings ("\\e", hex, and octal) in the string INPUT
 * into the corresponding integer byte. The converted string is copied
 * into the OUTPUT buffer. */
static void
transform_esc_seq(const char *input, char *output)
{
	const char *ptr = input;
	char *out_ptr = output;

	while (*ptr) {
		if (*ptr != '\\') {
			/* Not an escape string: copy the character as is. */
			*out_ptr++ = *ptr++;
		} else if (ptr[1] == 'e') { /* "\\e" */
			*out_ptr++ = '\x1b';
			ptr += 2;
		} else if (ptr[1] == 'x' /* Hex */
		|| (ptr[1] >= '0' && ptr[1] <= '9')) { /* Octal */
			const int hex = ptr[1] == 'x';
			const long n = strtol(ptr + (hex ? 2 : 1), NULL, hex ? 16 : 8);
			if (n < CHAR_MIN || n > CHAR_MAX) {
				ptr++;
			} else {
				*out_ptr++ = (char)n;
				ptr += 4;
			}
		} else {
			*out_ptr++ = *ptr++;
		}
	}

	*out_ptr = '\0';
}

static int
run_translate_key(const char *arg)
{
	if (!arg) {
		fprintf(stderr, "Missing parameter: An escape sequence is expected\n");
		fprintf(stderr, "E.g.: %s -t \"\\x1b[1;11D\"\n", PROG_NAME);
		return EXIT_FAILURE;
	}

#ifdef TK_TEST
	if (strcmp(arg, "test") == 0)
		return key_test();
#endif

	char *str = malloc((strlen(arg) + 1) * sizeof(char));
	if (!str)
		return ENOMEM;

	transform_esc_seq(arg, str);

	char *keysym = translate_key(str);
	free(str);

	if (keysym) {
		printf("%s\n", keysym);
		free(keysym);
		return EXIT_SUCCESS;
	}

	fprintf(stderr, "%s: '%s': Unknown escape sequence\n", PROG_NAME, arg);
	return EXIT_FAILURE;
}

static int
run_args(char **argv)
{
	if (!argv || !argv[0] || !argv[1])
		return EXIT_FAILURE;

	if ((argv[1][1] == 'h' && !argv[1][2])
	|| strcmp(argv[1], "--help") == 0) {
		print_help(); return EXIT_SUCCESS;
	}

	if ((argv[1][1] == 'v' && !argv[1][2])
	|| strcmp(argv[1], "--version") == 0) {
		printf("%s\n", VERSION); return EXIT_SUCCESS;
	}

	if ((argv[1][1] == 't' && !argv[1][2])
	|| strcmp(argv[1], "--translate") == 0)
		return run_translate_key(argv[2]);

	return EXIT_FAILURE;
}

static void
print_footer(char *buf, const int is_utf8, const int no_clear)
{
	char *str = translate_key(buf);

	const int wlen = (str && is_utf8 == 1) ? (int)wc_xstrlen(str) : 0;

	printw(" ├──────┴──────┴─────┴──────┤\n");
	printw(" │ %-*s │\n", TABLE_WIDTH + wlen, str ? str : "?");
	printw(no_clear == 1 ? BOTTOM_NO_CLR : BOTTOM_CLR);

	free(str);
}

int
main(int argc, char **argv)
{
	if (argc >= 2 && *argv[1] == '-')
		return run_args(argv);

	/* Tell the C libraries to use user's locale settings. */
	setlocale(LC_ALL, "");

	/* Initialize curses. */
	WINDOW *w = initscr();
	if (w == NULL) {
		fprintf(stderr, "Error initializing the curses library.\n");
		return EXIT_FAILURE;
	}

	raw();            /* Terminal in raw mode, no buffering */
	noecho();         /* Disable echoing */
	nonl();           /* Disable newline/return mapping */
	keypad(w, FALSE); /* FALSE: CSI codes, TRUE: curses codes for keys */
	scrollok(w, 1);	  /* Enable screen scroll */
	curs_set(0);      /* Hide cursor */

	printw(KP_HEADER, VERSION);

	const char *const keysym[] = {
		"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
		"BS", "HT", "LF", "CT", "FF", "CR", "SO", "SI", "DLE",
		"DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN",
		"EM", "SUB", "ESC", "FS", "GS", "RS", "US", "SP", NULL
	};

	/* For future reference: this should be made an option. */
	const int no_clear = 1;

	char buf[32] = ""; /* 32 bytes to hold a complete escape sequence. */
	char *ptr = buf;
	int clr_scr = 0;

	int utf8_bytes = 0; /* Number of bytes of a UTF-8 character. */
	int utf8_count = 0; /* Number of printed bytes of a UTF-8 character. */

	int c = 0;
	while ((c = getch()) != EXIT_KEY) { /* Ctrl+C */
		if (c == CLR_KEY                /* Ctrl+X */
		|| clr_scr == 1) {
			clr_scr = 0; clear(); refresh(); printw(KP_HEADER, VERSION);
			if (c == CLR_KEY)
				continue; /* Ctrl+X: do not print info about this key.  */
		}

		if (IS_CTRL_KEY(c)) { /* Control characters */
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*s │\n", c, c, c, 4,
				keysym[c]);
		} else if (isprint(c)) { /* ASCII printable characters */
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*c │\n", c, c, c, 4, c);
		} else { /* Extended ASCII, Unicode */
			const char *s = (c == 127 ? "DEL"
				: (c == 160 ? "NBSP" : (c == 173 ? "SHY" : "")));
			printw(" │ \\x%02x │ \\%03o │ %3d │ %*s │\n", c, c, c, 4, s);
			if (IS_UTF8_CHAR(c)) {
				utf8_count++;
				*ptr++ = c;
				int bytes = IS_UTF8_LEAD_BYTE(c)
					? utf8_char_bytes((unsigned char)c) : 0;
				if (bytes > 1)
					utf8_bytes = bytes;
			}
		}

		if (c == ESC_KEY) {
			*ptr++ = c;
		} else if (IS_CTRL_KEY(c) || (buf[0] == ESC_KEY && (END_CHAR(c)
		|| (!buf[1] && c != '[' && c != 'O')))) {
			/* Key combination involving modifier keys (Ctrl, Alt, Meta). */
			*ptr++ = c;
			*ptr = '\0';
			print_footer(buf, 0, no_clear);
			memset(buf, '\0', sizeof(buf));
			ptr = buf;
			clr_scr = no_clear == 0;
		} else if (utf8_bytes > 1 && utf8_count == utf8_bytes) {
			/* A UTF-8 character. */
			utf8_count = utf8_bytes = 0;
			*ptr = '\0';
			print_footer(buf, 1, no_clear);
			memset(buf, '\0', sizeof(buf));
			ptr = buf;
			clr_scr = no_clear == 0;
		} else if (buf[0] == ESC_KEY) {
			/* Append byte to the buffer only provided we are in the
			 * middle of an escape sequence. */
			*ptr++ = c;
		} else if (!IS_UTF8_CHAR(c)) {
			/* Print a bottom line (ASCII characters only). */
			printw(no_clear == 1 ? BOTTOM_NO_CLR_SINGLE : BOTTOM_CLR_SINGLE);
			clr_scr = no_clear == 0;
		}

	}

	curs_set(1); /* Unhide cursor */
	endwin();
	return EXIT_SUCCESS;
}
