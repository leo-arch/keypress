/* options.c */

/*
 * Copyright (C) 2025, Leo Abramovich <leo.clifm@outlook.com>
 * All rights reserved.

* The MIT License (MIT)

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

#define _XOPEN_SOURCE 700 /* expose getopt(3) in unistd.h */

#include <stdio.h>  /* puts, printf */
#include <stdlib.h> /* exit */
#include <unistd.h> /* getopt */

#include "options.h"  /* g_options, default macros */
#include "keypress.h" /* PROG_NAME, VERSION */

/* Global options variable */
struct opts_t g_options = {0};

static void
print_help(void)
{
	puts("Usage: keypress [OPTIONS]\n");
	puts("  -a      Enable Application Cursor Keys (DECCKM) mode.");
	puts("  -c      Do not clear the screen before displaying key information.");
	puts("  -h      Display this help and exit.");
	puts("  -i      Use ASCII characters to draw the table.");
	puts("  -I      Do not show terminfo capability names.");
	puts("  -k      Enable the Kitty keyboard protocol (disambiguate mode).");
	puts("  -K      Enable the Kitty keyboard protocol (full mode).");
	puts("  -l      Use a light color scheme.");
	puts("  -p      Run in HP keyboard mode.");
	puts("  -s      Run in SCO keyboard mode.");
	puts("  -n      Disable colors.");
	puts("  -t SEQ  Run in translation mode: translate the escape sequence\n"
		"          SEQ into its corresponding text/symbolic representation\n"
		"          and exit.");
	puts("  -T      Do not show key translations.");
	puts("  -u      Make XTerm emit CSI-u sequences (requires -x or -X).");
	puts("  -v      Display version information and exit.");
	puts("  -x      Enable Xterm's XTMODKEYS (disambiguate mode).");
	puts("  -X      Enable Xterm's XTMODKEYS (full mode, XTerm only).");

	printf("\nBy default, %s runs in interactive mode: it generates a\n"
		"byte-by-byte representation of keyboard inputs, whether for\n"
		"individual keys or key combinations.\n\n"
		"The output includes the following formats: hexadecimal, octal,\n"
		"decimal, and the corresponding symbols.\n", PROG_NAME);

	puts("\nMulti-byte Sequences:\n"
		 "Sequences such as extended ASCII, Unicode, or key combinations\n"
		 "involving function keys and arrow keys, will produce multiple\n"
		 "lines of output, with each line representing a single byte in\n"
		 "the sequence.");

	puts("\nImportant Notes:\n"
		 " - The generated byte values may vary depending on the terminal\n"
		 "   emulator used.\n"
		 " - Pasting from the primary clipboard is allowed.\n"
		 " - To quit the program, press 'Ctrl+c'.\n"
		 " - To clear the screen, press 'Ctrl+x'.\n"
		 " - The above key combinations are reserved for controlling the\n"
		 "   program's flow, so they will not be represented in the output.\n");

	puts("Reserved Key Combinations:\n"
		 "  The byte values for these keys are:\n\n"
		 "   ┌──────┬──────┬─────┬──────────┬──────┐\n"
		 "   │ Hex  │ Oct  │ Dec │   Bin    │ Sym  │\n"
		 "   ├──────┼──────┼─────┼──────────┼──────┤\n"
		 "   │ \\x18 │ \\030 │  24 │ 00011000 │  CAN │ (Ctrl+x)\n"
		 "   │ \\x03 │ \\003 │   3 │ 00000011 │  ETX │ (Ctrl+c)\n"
		 "   └──────┴──────┴─────┴──────────┴──────┘");
}

static void
set_colors(const int enabled)
{
	if (g_options.light_theme == 1) {
		g_options.colors.code = enabled == 1 ? CODE_COLOR_LIGHT : "";
		g_options.colors.header = enabled == 1 ? HEADER_COLOR_LIGHT : "";
		g_options.colors.reset = enabled == 1 ? RESET : "";
		g_options.colors.symbol = enabled == 1 ? SYM_COLOR_LIGHT : "";
		g_options.colors.table = enabled == 1 ? TABLE_COLOR_LIGHT : "";
		g_options.colors.translation = enabled == 1 ? TRANS_COLOR_LIGHT : "";
	} else {
		g_options.colors.code = enabled == 1 ? CODE_COLOR : "";
		g_options.colors.header = enabled == 1 ? HEADER_COLOR : "";
		g_options.colors.reset = enabled == 1 ? RESET : "";
		g_options.colors.symbol = enabled == 1 ? SYM_COLOR : "";
		g_options.colors.table = enabled == 1 ? TABLE_COLOR : "";
		g_options.colors.translation = enabled == 1 ? TRANS_COLOR : "";
	}
}

static void
init_default_options(void)
{
	g_options.app_cursor_keys = DEFAULT_APP_CURSOR_KEYS;
	g_options.ascii_draw   = DEFAULT_ASCII_DRAW;
	g_options.clear_screen = DEFAULT_CLEAR_SCREEN;
	g_options.color        = DEFAULT_COLOR;
	g_options.hp_keys      = DEFAULT_HP_KEYS;
	g_options.kitty_keys   = DEFAULT_KITTY_KEYS;
	g_options.light_theme  = DEFAULT_LIGHT_THEME;
	g_options.sco_keys     = DEFAULT_SCO_KEYS;
	g_options.show_terminfo_cap = DEFAULT_SHOW_TERMINFO_CAP;
	g_options.show_translation = DEFAULT_SHOW_TRANSLATION;
	g_options.translate    = DEFAULT_TRANSLATE;
	g_options.xterm_csi_u  = DEFAULT_XTERM_CSI_U;
	g_options.xterm_mok    = DEFAULT_XTERM_MOK;
}

void
parse_cmdline_args(const int argc, char **argv)
{
	init_default_options();

	int opt;
	while ((opt = getopt(argc, argv, "achiIkKlnpst:TuvxX")) != -1) {
		switch (opt) {
		case 'a': g_options.app_cursor_keys = 1; break;
		case 'c': g_options.clear_screen = 0; break;
		case 'i': g_options.ascii_draw = 1; break;
		case 'I': g_options.show_terminfo_cap = 0; break;
		case 'k': g_options.kitty_keys = 1; break;
		case 'K': g_options.kitty_keys = 2; break;
		case 'l': g_options.light_theme = 1; break;
		case 'n': g_options.color = 0; break;
		case 'p': g_options.hp_keys = 1; break;
		case 's': g_options.sco_keys = 1; break;
		case 't': g_options.translate = optarg; break;
		case 'T': g_options.show_translation = 0; break;
		case 'u': g_options.xterm_csi_u = 1; break;
		case 'v': printf("%s\n", VERSION); exit(EXIT_SUCCESS);
		case 'x': g_options.xterm_mok = 1; break;
		case 'X': g_options.xterm_mok = 2; break;
		case 'h': /* fallthrough */
		default: print_help(); exit(EXIT_SUCCESS);
		}
	}

	const char *no_color = getenv("NO_COLOR");
	if (no_color && *no_color)
		g_options.color = 0;
	set_colors(g_options.color);
}
